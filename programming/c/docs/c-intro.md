---
title:  Introduction to C
author: CSC Summerschool 
date:   2019-07
lang:   en
---


# What is C?

- C is a *general-purpose* programming language initially developed by
Dennis Ritchie between 1969 and 1973 at AT\&T Bell Labs

- It is an imperative procedural language intended for system software
  * Strong ties with UNIX operating system
- It has influenced many other programming languages
  * C++, C\#, ObjC, Java, JavaScript, Go, csh, ...

# Why C?

 - It’s popular and widely used

  * Available on almost all platforms
  * Lots of libraries for different tasks

- Provides a relatively low-level (or mid-level) access to the operating
 system and hardware

  * System-level programming, embedded systems
  * Can lead to better performance

# Standards

- First standard by ANSI in 1989, known as “ANSI C” or C89

  * Still the best choice when portability is important\!
  * ISO adopted the same standard in 1990 (C90)

- Next revision in 1999, C99

  * New datatypes, complex numbers, variable length arrays,...

- Current standard is C11

  * Improved Unicode support, atomic operations, multi-threading, bounds-checked functions, ...

**On this course we will use mainly ANSI C/C90 or C99**

# Getting started{.section}

# Look and feel
<small>
```c
/* Computing the factorial of an specified (by the user) number */
#include <stdio.h>

int fact(int n);

int main(void){
	int current;
	printf("Enter some POSITIVE integer (non-positive to finish): ");
	scanf("%d", &current);
	while (current > 0) {

		printf("Factorial of %d is %d\n", current, fact(current));

		printf("Enter a POSITIVE integer (non-positive to finish): ");

		scanf("%d", &current);
	}
}
/* This function returns the factorial of the specified integer (n)*/
int fact(int n) {
...
```
</small>

# Basic syntax

<div class="column">
  - Code is case sensitive
  - Statements terminate with ;
  - {} enclose blocks
  - There are two ways to comment :

```c
/* This is a very long and complicated comment,
which contains a lot of useful information */

// This is a short comment
```
</div>

<div class="column">
```c
/* example function */
float foo(int bar) {
	int i, c=0;
	float x;
	x = 0.1;
	for (i=0; i\<bar; i++) {
		x += i\*3.14 + c;
		c = i + 2;
	}
	return x;
}
```
</div>

# Basic syntax

Free format

  - whitespace, newlines, layout etc. do not matter …
**To the computer!!**

<div class="column">
```c
/* example function */
float foo(int 
bar) {int i,c=0;float x;x = 0.1;for
(i     =0;i<bar;
i++) {
x += i*3.14       + c;
c = i + 2;}return x;}
```
</div>
<div class="column">
```c
/* same example function? */
float foo(int bar) {
	int i, c=0;
	float x;
	x = 0.1;
	for (i=0; i<bar; i++) {
		x += i*3.14 + c;
		c = i + 2;
	}
	return x;
}
```
</div>
# Simple Input / Output (I/O)

  - stdio-library is almost always needed. To include it use:  
	`#include <stdio.h>`
  - For printing a text on the screen:
	`printf(<template> {, <variables>})`

	* `<template>` arbitrary string with optional placeholders for data from variables
	* `<variables>`	(optional) a list of variables

# Basic I/O

- Special characters that can be used in the template string:  
**\\n** newline	      
**\\t** horizontal tab  
**\\”** double quote	 
**\\\\** literal backlash  
- Placeholders are marked with **%** followed by formatting and type
information

  * For now, we will just use the following formattings:   
  **%d** integer value  
  **%f** float value  
  **%s** string

# Basic I/O example
```c
#include <stdio.h>
int main(int argc, char *argv[]) {
	printf("The answer is %d.\n", 42);
	printf("Pi equals to %.2f", 3.14159265);
	printf(" ...at least to the %dnd decimal.\n", 2);
	return 0;

}

//output:
// The answer is 42.
// Pi equals to 3.14 ...at least to the 2nd decimal.
```
# **The transition from Code to program**

<div class="column">
- Compiling:

  * Transforming the C source code to machine language

- Linker:

  * Combines object files generated by the compiler into a single executable program

- The result is an executable binary file
</div>
<div class="column">
```c
/*file.c*/
#include <stdio.h>
void main() {
int i,j=0;
float f=1.0;
for (i=0; i<8; i++) {
	j += i;
	f *= j+i;
}
```
<small>
**file.c**->**prepreocessor**->**compiler**->**linker**->**program**  
</small>


# Let's try it out\!
<small>
  
  - Write the classic first program in C:

  ```c
  #include<stdio.h>
  void main(){
  	printf("Hello World!\n");
  }

  ```
  
  - Compile the code:
  
  ```bash
  $ gcc -o hello hello.c
  ```
  - Test your program:
  
  ```bash
  $ ./hello
  Hello World!
  ```

</small>

# Datatypes, variables, assignment and operators{.section}

# Basic data types

  - Basic datatypes in C are: 
  	* **char** character 
  	* **int** integer number
  	* **long** long integer number 
  	* **float** floating point number
  	* **double** double precision float
  - C has also *pointer* types
  - There is also a special type **void**

# Variables
<div class="column">
  - Data types of the variables are static
  - Declare variables before using them
  - Valid variable names in C:  
  	`[a-z][A-Z][0-9]_`
  - Scope of a variable is always local unless otherwise declared
</div>

<div class="column">
```c
// variable declaration
int i;
float f, g;
double total=1.9;
// valid names
int i3, myINT, I_o;
float o3Gf_ry9;
// invalid names
int 33, 9a, i-o;
float o3.Gf;
// data type matters
char c;
float f;

f = 1.234;
c = f; // ERROR!, wrong data type
```
</div>
# Variable assignment
<div class="column">
- Assign a value to a variable: **variable = value;**  

- Both should have the same data type

  * implicit conversion between compatible types
  * explicit conversion (typecast) syntax: **(type) var**
</div>
<div class="column">
```c
// examples of assignment
count = 10;
i = j = 0;
k = i*j + 1;

// assign at declaration
int i = 4;

// typecast from int to float
int i;
float f;
i = 5 * 21;
f = (float) i;

// watch out for operator order
(float) i/5 != (float) (i/5)
```
</div>


# Arithmetics

- Operators: `+  -  *  /  %`

Operator precedence

  - **%** **\*** **/**
  - **+** **-**

Parentheses group operations () and change evaluation order

**+** addition **–** subtraction **\*** multiplication **/** division
**%** modulus

# **Compound assignment**

  - C has a short-hand notation for combined arithmetic operation and
    assignment a += b equals a = a + b a -= b a = a - b a \*= b a = a \*
    b a /= b a = a / b
  - For special cases **a+=1** and **a-=1** there are special operators
    **++** and **--**

**// example of compound assignment**

**int count = 10;**

**count += 5; // now count is 15**

**count /= 3; // and now count is 5**

****

**// Adding one to count**

**count++;**

****

**// This is also valid\!**

**++count;**

****

# **Arithmetics and assignment examples**

## **// addition, substraction**

## **i = 5 + 2;**

## **i = 5 – 2;**

## **i += 1; // i = i + 1**

## **f -= 3.4;**

## **i++; // i = i + 1**

## **i--;**

## ****

## **// multiplication, division**

## **i = 5 \* 2;**

## **i = 5 / 2; // integer division**

## **f \*= 3.0 / 4.2;**

## ****

## **// modulus**

## **m = 25 % 3;**

**// grouping with ()s**

**b = a \* (1.3 + (25%3));**

****

**// watch out\!**

**f = 1 + q / (1 - q);**

**f = (1 + q) / (1 - q);**

****

**// also functions use ()**

**f = r \* sin(theta);**

**f = (r + p)\*sin(theta);**

# **Pointers**

  - A variable is actually a reference to a memory location
  - The contents of the memory block determine the value of a variable
  - Memory addresses can be stored (and manipulated) in pointers
  - Pointers are one of the key features (and one of the most difficult)
    of the C language\!

# **Pointers**

  - Pointers have a type (**int, char** etc.)
  - Stores a memory address containing data of corresponding type

**int a**

memory

int \*p

address

# **Pointers**

  - The address of a variable is obtained with **&**
  - The value pointed at by a pointer (the contents of the address) can
    be accessed by de-referencing the pointer with **\***

**int \*p, a;**

****

**a = 5;**

**// get address of a**

**p = \&a;**

**// assign to a the value pointed at by \*p plus 2**

**a = (\*p) + 2; // a=7**

# **Summary**

  - Short history and different standards
  - Basic syntax
  - Variables and their type, assignment of values
  - Arithmetic operations

# **Control structures and loops**

# **Control structures // if – else**

## ****

## ****

  - if (conditional) {TRUE} else {FALSE}
  - test operators:
  - negation: \!
  - non-zero value == TRUE

**== equal to**

**\!= not equal to**

**&& AND**

**|| OR**

**\< less than**

**\> greater than**

**\<= less or equal**

**\>= greater or equal**

**if (i \< 100) {**

**data\[i\] = x\[i\] + c**

**} else {**

**data\[i\] = x\[i\] - c**

**}**

# **Control structures // if – else**

## **// simple if-else**

## **if (x \> 1.2) {**

## **y = 4\*x\*r; // TRUE**

## **} else {**

## **y = 0.0; // FALSE**

## **}**

## ****

## **// else is optional**

## **if (x || y) {**

## **z += x + y;**

## **}**

**// complex if-elseif-else**

**if ((x \> 1.2) && (i \!= 0) )**

**{**

**y = x / i; // 1st TRUE**

**} else if (x \< 1.0 ) {**

**y = -x; // 1st FALSE**

**// 2nd TRUE**

**} else {**

**y = 0.0; // 1st, 2nd FALSE**

**}**

# **Control structures // switch**

switch (...) { case (...): ... break; default: ... }

condition:

  - single variable OR complex expression

branch(=case) with matching value chosen

break stops branch

conditional expression

test value

end of branch

default branch executed

if nothing else matches

# **Control structures // switch**

## **// simple switch based on the**

## **// value of integer i**

## **switch (i) {**

## **case 1:**

## **printf("one\\n");**

## **break;**

## **case 2:**

## **printf("two\\n");**

## **break;**

## **default:**

## **printf("many\\n");**

## **break;**

## **}**

good style to break even the last branch\!

# **Control structures // switch**

**switch (i) {**

**case 1:**

**printf("one\\n");**

**case 2:**

**printf("two\\n");**

**default:**

**printf("many\\n");**

**}**

**switch (i) {**

**case 1:**

**printf("one\\n");**

**break;**

**case 2:**

**printf("two\\n");**

**break;**

**default:**

**printf("many\\n");**

**}**

**switch (i) {**

**default:**

**printf("many\\n");**

**case 1:**

**printf("one\\n");**

**break;**

**case 2:**

**printf("two\\n");**

**break;**

**}**

A

B

C

In each case, what would be printed on the screen if i is 1, 2, or 3?

# **Loops // while**

## ****

## ****

**while (...) {...}**

Code block executes repeatedly as long as condition is TRUE

Condition executed *before* iteration

**do {...} while (...)**

  - Block executed at least once

condition

code block

**// loop i = 0..99 with an increment of one**

**i = 0**

**while (i\<100) {**

**data\[i\] = x\[i\] + c**

**i++;**

**}**

# **Loops // for**

## ****

## ****

## ****

  - **for (\<init\>; \<condition\>; \<after\>) {...}**

**// loop i = 0..99 with an increment of one**

**for (i=0; i\<100; i++) {**

**data\[i\] = x\[i\] + c**

**}**

# **Loops // for**

## **// loop using a for-statement**

## **// i is incremented after each iteration**

## **for (i=0; i\<bar; i++) {**

## **x += i\*3.14 + c;**

## **c = i + 2;**

## **}**

## ****

## **// the same loop but with a while-statement**

## **i=0;**

## **while (i \< bar) {**

## **x += i\*3.14 + c;**

## **c = i + 2;**

## **i++;**

## **}**

# **Jump statements**

**break**

  - end a loop (for, while, do) or a switch statement

**continue**

  - continue with the next iteration of a loop

**// jump out of a loop**

**for (i=0; i\<10; i++) {**

**printf("in loop");**

**if (i == x)**

**break;**

**}**

****

****

**// jump to the next iteration**

**for (i=0; i\<10; i++) {**

**if (i \< x)**

**continue;**

**printf("in loop");**

**}**

# **Summary**

  - Conditional branching: if-else, switch
  - Looping as long as condition is true: while, do – while
  - Fixed number of loop passes: for
  - Jump statements: continue, break

# **Data structures and functions**

# **Arrays**

  - Static arrays declared as **\<type\> name\[N\]** where **N** is the
    size of the array **int i\[10\]** array of 10 integers **float
    f\[3\]** array of 3 floats **char c\[60\]** string of 60 letters
  - elements indexed starting from zero **i\[3\]** 4th element of array
    i
  - multi-dimensional arrays possible **int m\[10\]\[20\]** a 10x20
    matrix

# **Arrays**

## **// integer vector**

## **int triplet\[3\];**

## ****

## **triplet\[0\] = 1;**

## **triplet\[1\] = 2 \* triplet\[0\];**

## **triplet\[2\] =**

## **triplet\[0\] + triplet\[1\];**

## ****

## **// string**

## **char word\[\] = "hello\!";**

## **printf(word); // hello\!**

**// 2-dim matrix**

**int i,j;**

**float matrix\[5\]\[5\];**

****

**for (i=0; i\<5; i++)**

**for (j=0; j\<5; j++)**

**matrix\[i\]\[j\] = i\*j;**

****

**// print the 2nd row**

**for (i=0; i\<5; i++)**

**printf("%f ", matrix\[1\]\[i\]);**

# **Pointer arithmetic and arrays**

Pointers can be added to or subtracted from

  - This shifts the pointer to a new memory address before or after the
    current one
  - Each step is **sizeof(pointer\_datatype)** bytes, i.e. the memory
    size of the pointer's data type

Watch out for out-of-bounds memory errors\!

**float vector\[10\], \*ptr;**

****

**ptr = \&vector\[0\]; // \*ptr -\> vector\[0\]**

**ptr = vector; // name of array works as pointer to the beginning**

**ptr++; // \*ptr -\> vector\[1\]**

**ptr += 3; // \*ptr -\> vector\[4\]**

**ptr--; // \*ptr -\> vector\[3\]**

# **Structures**

  - Multiple variables of arbitrary type can be grouped together in a
    **struct**
  - Member **y** of struct **x** accessed with **x.y** (or **x-\>y** if
    x is a pointer)

**struct s {**

**int i;**

**float f;**

**} one;**

****

**typedef struct {**

**int count;**

**float price;**

**} apple;**

**apple a;**

****

**a.count = 7;**

**a.price = 1.24;**

**cost = a.count \* a.price;**

****

**// with pointers**

**apple \*ptr;**

**ptr = \&a;**

**c = ptr-\>count;**

**ptr-\>price = 0.89;**

# **Functions**

Functions are the only subroutine type in C

  - But functions do not have to return anything

Function definitions are of form

Here **type** is the return type of the function

  - **void** means that function does not return anything

**type func-name(param-list)**

**{**

**/\* body of function \*/**

**}**

# **main function**

Every C program has the main function with definition

Command line arguments are passed to the program using **argc** and
**argv**

main should always return integer

  - zero means success, non-zero values are errors

**int main(int argc, char \*argv\[\])**

**{**

**/\* body of function \*/**

**}**

# **Function example**

  - This function returns the sum of two integer arguments:

**\#include \<stdio.h\>**

**int add(int a, int b) {**

**return a + b;**

**}**

****

**int main(void) {**

**int val;**

**val = add(3, 6);**

**printf(“Sum is %i\\n”, val);**

**return 0;**

**}**

# **Variable scoping**

Variable scoping in C is local unless defined otherwise

  - Variables declared in the function definition are only visible
    inside the function body
  - Variables of calling scope are not visible inside function body

**void funcB(float a) {**

**int counter;**

**...**

**}**

**int funcA(void) {**

**float value\_1, value2;**

**funcB(value\_1);**

**...**

**}**

Not accessible from **funcA**

Not accessible from **funcB**

# **Arguments**

All arguments are passed as *values*

  - Copy of the value is passed to the function
  - Functions can not change the value of a variable in the *calling
    scope*

Pointers can be used to pass a reference to a variable as an argument\!

**void funcB(int a) {**

**a += 10;**

**}**

****

**int funcA(void) {**

**int var = 0;**

**funcB(var);**

**// var is still 0\!**

**...**

**}**

# **Functions with pointers**

  - Pointers allow “returning” of multiple values

**// passing by reference**

**void add\_pi(float \*a, int \*b) {**

**float pi=3.14;**

**\*a += pi;**

**(\*b)++;**

**}**

**float a=1.0;**

**int b=1;**

****

**add\_pi(\&a, \&b); // a=4.14 b=2**

# **Dynamic arrays**

# **Dynamic memory management**

  - In most cases the exact size of all data structures is not known at
    compile time because they depend on the input data
  - Dynamic memory management is accomplished by using pointers and
    manually managing memory (de)allocation
  - Relevant functions are **malloc()**, **realloc()**, **free()**

# **malloc**

malloc function is defined in header file stdlib.h: **void
\*malloc(size\_t size);**

**malloc** returns a pointer of type **void** to a memory location with
allocated space of size **size** bytes

  - If allocation fails, **malloc** returns **NULL\!**

The memory area returned by the malloc is uninitialized\!

# **Dynamic arrays**

**malloc** can be used to allocate space for arrays

  - **malloc** returns a pointer to the beginning of the array
  - Elements can be accessed with normal array syntax

The size of memory allocation can be determined using **sizeof**
operator which returns the size of the argument in bytes

Example for a dynamic array of five integers: **int \*ptr = (int \*)
malloc(5 \* sizeof(int));**

# **free**

**free** deallocates previous allocated object **void free(void
\*ptr);**

After freeing you should not try to access any part of the allocation

Calling free with a pointer that does not point to a allocated memory
can crash the code

  - Calling free twice is a common mistake\!

# **Dynamic arrays**

## **int n\_elems = 32;**

## **float \*prices;**

## ****

## **// allocate memory for the required amount of floats**

## **prices = malloc(n\_elems\*sizeof(float));**

## **for (i=0; i\<n\_elems; i++) {**

## **prices\[i\] = i\*1.23;**

## **}**

## **// add space for one more float**

## **prices = realloc(prices, sizeof(float)\*(n\_elems+1));**

## **prices\[n\_elems\] = 0.91;**

## **// de-allocate the memory block**

## **free(prices);**

# **Pointers to pointers**

It is possible to have pointer references to pointers

  - This is very useful when functions have to manipulate values of
    arguments of pointer type
  - Multidimensional arrays are also naturally mapped into pointers of
    pointers

# **Pointer to a pointer example**

**\#include\<stdio.h\>**

****

**int main(void) {**

**int a = 5;**

**int \*int\_ptr;**

**int \*\*int\_ptr\_ptr;**

****

**int\_ptr\_ptr = \&int\_ptr;**

**int\_ptr = \&a;**

****

**printf(“a=%i\\n”, \*\*int\_ptr\_ptr);**

**return 0;**

**}**

****

**// Result: a=5**

# **Dynamic multi-dimensional arrays**

Doable, but becomes complicated

No real multi-dimensional arrays in C, so really just arrays of arrays

  - Two dimensional array maps to a variable that is a pointer to a
    pointer

Memory management by hand

  - There are at least two different ways to do the allocation
  - Easy to make mistakes, beware here lieth dragons\!

Often best to just use 1D array and map N dimensional indices

# **Allocating row-by-row**

## **int i;**

## **int rows = 4, cols = 8;**

## **float \*\*matrix;**

## ****

## **/\* allocate memory \*/**

## **matrix = malloc(rows \* sizeof(float \*));**

## **for (i = 0; i \< rows; i++)**

## **matrix\[i\] = malloc(cols \* sizeof(float));**

## ****

## **// start using the 2D array**

## **matrix\[0\]\[2\] = 3.14;**

**matrix**

**matrix\[i\]**

**matrix\[i\]\[j\]**

Do not do this\!

# **Dynamic multi-dimensional arrays**

## Dynamic 2D array in *contiguous* memory:

  - First, allocate memory for pointers to the first element of each row
  - Second, allocate memory for all elements
  - Third, point each row at the first element of that row

# **Dynamic multi-dimensional arrays**

## **/\* allocate memory \*/**

## **matrix = malloc(rows \* sizeof(float \*));**

## **matrix\[0\] = malloc(rows \* cols \* sizeof(float));**

## ****

## **/\* point the beginning of each row at the correct address \*/**

## **for (i = 0; i \< rows; i++)**

## **matrix\[i\] = matrix\[0\] + i \* cols;**

## ****

## **// start using the 2D array**

## **matrix\[0\]\[2\] = 3.14;**

**matrix**

**matrix\[i\]**

**matrix\[i\]\[j\]**

# **Memory layout**

Allocating space for the whole array using a single malloc call is the
recommended way

  - Number of expensive malloc calls is minimized
  - Array is represented as one contiguous block in memory
  - It can be copied without looping over rows
  - Most IO and numerical libraries assume contiguous storage

# **Dynamic multi-dimensional arrays**

  - After using a dynamic multi-dimensional array, remember to free each
    array inside the main array

## ****

## **/\* When using contiguous memory \*/**

## **free(matrix\[0\]);**

## **free(matrix);**

# **Using indexing to represent 2D array**

Allocate memory for all elements as normal 1D array

Compute indices so that the 1D memory area map to the 2D array we want
to represent

Benefits

  - The compiler understands better the code, and hence performance may
    be better
  - Allocation and deallocation easier
  - Straightforward to generalize to higher dimensions

Drawbacks

  - Code may look less
elegant

# **Using indexing to represent 2D array**

## **/\* matrix now normal pointer \*/**

## **float \*matrix;**

## ****

## **/\* allocate memory \*/**

## **matrix = malloc(rows \* cols \* sizeof(float));**

## ****

## **/\* start using the array, element \[i\]\[j\] in 2D array now maps to \[i \* cols + j\]\*/**

## **matrix\[0 \* cols + 2\] = 3.14;**

## ****

## **/\* free memory \*/**

## **free(matrix);**

**matrix**

**matrix\[i \* cols + j\]**

# **Preprocessing and libraries**

# **Preprocessing directives**

C preprocessor is a part of the compiler that does initial text
substitution, manipulation, inclusion and other activities before the
actual translation is done

  - We have already used **\#include**, which includes a file

C relies heavily on preprocessor to accomplish

  - Portability of code
  - Source code control
  - Debugging

# **Directives**

Preprocessor directives start with **\#**, which has to be first token
on a line

Directives are limited to one line

  - Line can be continued using **\\**

Directives are not statements, do not end the line with **;**

**// These are ok**

**\#define one**

**\#define two**

**// Not the first token - WRONG\!**

**int i; \#define one**

# **\#define**

  - **\#define** can be used to define “objects” or macros
  - It has the form of \#define *identifier* *replacement*
  - After the definition all instances of ***identifier*** are replaced
    with ***replacement***

**// Example**

**\#define ONE 1**

**printf(“Value is %i\\n”, ONE);**

**// Result: Value is 1**

# **Directives**

**\#ifdef, \#ifndef**

  - checks whether a macro is defined (/ not defined)
  - if check is true, then includes the enclosed code

**\#include \<stdio.h\>**

**\#include "myfile.h"**

****

**\#define DEBUG 1**

**\#define PI 3.14159**

**\#define MAX(a,b) (a)\>(b)?(a):(b)**

****

**\#ifdef DEBUG**

**/\* debug mode is enabled \*/**

**\#endif**

# **Definitions on compiler command line**

  - It is also possible to set preprocessor definitions on the compiler
    command line
  - Most compilers accept option **-D** for this purpose: **gcc -DONE=1
    -DUSE\_FEATURE** is equivalent with **\#define ONE 1 \#define
    USE\_FEATURE**

# **The transition from Code to program**

Compiling:

  - Transforming the C source code to machine language

Linker:

  - Combines object files generated by the compiler into a single
    executable program

The result is an executable binary file

**\#include \<stdio.h\>**

****

**void main() {**

**int i,j=0;**

**float f=1.0;**

**for (i=0; i\<8; i++) {**

**j += i;**

**f \*= j+i;**

**}**

compiler

program

gcc, cc, ...

./foo

foo.c

preprocessor

compiler

linker

# **Working with several files and libraries**

Advantages:

  - Different programmers can work on different files
  - Function definitions can be re-used in other programs
  - Changing a file, only that file needs to be re-compiled to rebuild
    the program

UNIX ‘make’ can be very useful tool for this\!

  - Most IDEs also provide a tools for building this kind of compilation

# **Compilation: working with several files**

  - We use header files to define functions that we can use later
  - Making .h files for your functions allows you to ‘include’ them in
    your code

**// we define the function ‘add’**

**\#ifndef ADD\_H**

**\#define ADD\_H**

**int add(int first, int second);**

**\#endif**

**// we implement the function ‘add’**

**int add(int first, int second)**

**{**

**return first + second;**

**}**

File: add.c

File: add.h

This is called **function prototype.** It introduces the return value,
name and arguments of the function to the compiler

# **Compilation: working with several files**

  - Another .c file can then use the function add() by including the
    header file:

**// we can use \#include "" or \#include \<\>**

**\#include "add.h"**

****

**int example(int x)**

**{**

**return add(x, add(x,x));**

**}**

# **Compilation: working with several files**

So, this is how headers work:

  - main() would be in one file, the others will contain functions
  - Headers usually only contain definitions of data types, function
    prototypes and C preprocessor commands
  - We include the header into the C files
  - We compile the different files and the compiler calls the header
    file

# In complex projects:

In complex projects:

  - Compile each source code file (.c) into an object file (.o)
  - Link object files into a binary and execute the binary

**The transition from Code to program**

**$ gcc -c main.c**

**$ gcc -c add.c**

**$ gcc -o foo main.o add.o**

**$ ./foo**

***Modify “add.c”***

**$ gcc –c add.c**

**$ gcc -o foo main.o add.o**

**$ ./foo**

# **Libraries**

Libraries contain functions, data types and constants that can be used
by multiple programs

Two components:

  - header: function etc. definitions
  - object code in a library file (shared .so or static .a)

When creating the executable binary file, an additional flag
(–l*library\_name*) is given to the linker to include the library

# **Libraries**

  - Math operations
  - It includes the most common mathematical functions, e.g. sin(),
    cos(), log() etc.
  - Also includes constants such as M\_PI for π
  - For power operation function pow() is used (^ is bit-wise XOR in C
    \!)

**\#include \<math.h\>**

****

**int main () {**

**float r, theta;**

**double area, y;**

****

**// radius and an angle**

**r = 1.2;**

**theta = 0.456;**

****

**// calculate something**

**area = M\_PI \* pow(r,2);**

**y = sin(theta)**

**+ cos(theta/2.0);**

**y += exp(-3.1 \* area);**

****

**// echo results**

**printf("area is %f\\n", area);**

**printf("y=%.18e\\n", y);**

**}**

**\#include \<math.h**\>

\+ link with -lm flag\!

# Add libraries in linking phase

  - Add libraries in linking phase

**Linking with libraries**

**$ gcc -c main.c**

**$ gcc -o foo main.o -lm**

**$
./foo**

# Compiler flags provides possibilities of also for code optimization. Few instances of the optimization flags are -O, -O0, -O1, -O2, -O3, -Os.

  - Compiler flags provides possibilities of also for code optimization.
    Few instances of the optimization flags are -O, -O0, -O1, -O2, -O3,
    -Os.
  - For further information check the manual of gcc:

**Compiler optimization**

**$ gcc -O3 -o toroid -lm toroid.c**

**$ ./toroid**

**$ man gcc**

# **File I/O**

# **File I/O**

  - **fopen(\<filename\>, \<mode\>)**  **FILE\***
  - **fclose(FILE\*)**  closes file
  - **fflush(FILE\*)**  flush I/O buffer to disk

**r, w, a read, write, append r+, w+, a+ read+write rb, wb, ... binary
mode**

**name of a file**

**pointer to file**

# **File I/O**

**stdout, stderr**

  - special output streams for STDOUT and STDERR (stdio.h)

**fprintf(\<file\>, \<template\> {,
\<variables\>})**

## **\<file\>** pointer to an open file

## **\<template\>** arbitrary string with optional placeholders for data from variables

## **\<variables\>** (optional) a list of variables

# **File I/O**

## **\#include \<stdio.h\>**

## ****

## **fprintf(stdout, "The answer is %d.\\n", 42);**

## **//output (STDOUT):**

## **// The answer is 42.**

## ****

## **fprintf(stderr,**

## **"Pi equals to %.2f (at least to the %dnd decimal).\\n",**

## **3.14159265, 2);**

## **//output (STDERR):**

## **// Pi equals to 3.14 (at least to the 2nd decimal).**

# **File I/O**

## **\#include \<stdio.h\>**

## ****

## **FILE \*fp;**

## **int pid=2146;**

## ****

## **fp = fopen("mylog", "w");**

## **fprintf(fp, "logging my progress for process %d...", pid);**

## **fprintf(fp, "ok\\n");**

## **fclose(fp);**

## ****

## **//output (in file 'mylog'):**

## **// logging my progress for process 2146...ok**

# **File I/O**

**fgets(char \*buffer, int size, FILE \*stream)**

  - Reads a single line from file pointer stream
  - Assigns string to buffer
  - The size parameter defines the max. size of characters to read.

# **File I/O**

**fscanf(FILE \*stream, char \*format, ...)**

  - scan input according to format e.g. "name: %s age: %d"
  - store values of placeholders (%s etc.) to pointers

**// read max 64 characters from FILE \*fp**

**fgets(buffer, 64, fp);**

****

**// read a matching string from FILE \*fp, pick a string and**

**// an integer and assign them to variables name and age**

**fscanf(fp, "name: %s age: %d", \&name, \&age);**

# **Summary**

  - Basic syntax
  - Overall structure: \#include, functions, main()
  - Data types: int, float, ..., struct
  - Control structures: for, while, if/else, switch/case
  - Memory management: pointers, malloc(), ...
  - I/O: files, stdin, stdout
  - Compiling & linking

# **Web resources**

  - C Programming http://en.wikibooks.org/wiki/C\_Programming
  - The C Library Reference Guide
    http://www.acm.uiuc.edu/webmonkeys/book/c\_guide/
  - C syntax http://en.wikipedia.org/wiki/C\_syntax
  - Ten Reasons to Teach and Learn Computer Programming in C
    http://iel.ucdavis.edu/publication/WhyC.html
  - International Obfuscated C Code Contest
    http://en.wikipedia.org/wiki/International\_Obfuscated\_C\_Code\_Contest

# **Say what?**

## static signed char a\[\] = {0x69,

## 110, 118, 97, 108, 105, 0x64, 1-1,

## 0x6d, 111, 118, 101, 1\<\<1\<\<1\<\<1\<\<1\<\<1,

## 114, 105, 0x6e, 103, 32, 'o'/3, 100,

## 32, 102, 114, 111, 0x6d, 32, 115, 116,

## 97, 100-001, 107, 32,37, 2\*'2', '@'\>\>1,

## 116, '%' + '%' + '%','w'-'W',115, 0x74,

## 97, 3\*'\!', 107, 'q' - 'Q', 37, 10\*'\\n',

## 10, 0}, \* b = a + (1\<\<1\<\<1\<\<1), \* w, x,

## \*q, c, r; int main(int d, char \*e \[\]) {

## return q = (signed char \*)(e+1+1), (r =

## e\[0\] && e\[1\] ? 0 : 0 \* puts (a) + 1) ||

## (r = e\[1\<\<1\] && d \!= 1 \<\<1 && 0 \* puts(

## a) + 1) || e\[1- -1\] || (r = atoi(e\[1\])

## \< -0200 || atoi (e \[1\]) \> 0x7f || ( x =

## atoi( e\[1\] ) ) == 0 ? 0 \* puts(a) + 1 :

## 0\) || e \[1- -1\] || (x- -x \> 1-1 ? (q\[0\]

## \= x, q\[1\] = q\[3\] = 1, q\[2\] = 2) : (

## memset ( w = ( signed char \* )

## malloc(-x), '1', -x), puts (w),

## q\[0\] = x, q\[1\] = '0', q\[2\] = q\[3\] =

## 0)), r || (q\[3\] ? (c = 6 - q\[1\] - q\[2\],

## (q\[0\] \!= 1) ? q\[0\]-- , d = q\[2\], q\[2\] =

## c, main(2, e), c = q\[2\], q\[2\] = d, q\[0\]

## \++ : 0, printf(b, q\[0\], q\[1\], q\[2\]), (q

## \[0\] \!= 1) ? q\[0\]--, d = q\[1\],q\[1\] = c ,

## main(2, e), c = q\[1\], q\[1\] = d, q\[0\] ++

## : 0) : - 1 - q\[0\] - 1 == 0 ? (w\[- x – 1

## \- (q\[1\] & 1 ^ 1)\] = q\[1\], puts (w), w \[

## \- x - 1 - (q\[1\] & 1)\] = q\[1\], puts(w) )

## : - 1 - q\[0\] == 0 ? (w\[- x - 1\] = q\[ 1

## \], puts(w)) : (q\[0\] += 1 + ( q\[1\] & 1

## ^ 1), main(2, e), q\[0\] -= 1 + ( q

## \[1\] & 1 ^ 1), q\[1\] & 1 ? (q

## \[0\]+=1+1, q\[1\]^=1, main

## (2, e), q\[1\]^=1, q\[0\]-=1

## \+1) : 0, w\[q\[0\] - x\] = q

## \[1\], puts(w), q\[1\] & 1 ?

## 0 : (q\[0\]+=1+1, q\[1\]^=1,

## main (2, e), q\[1\]^=1, q

## \[0\]-=1+1), q\[0\] += 1 +

## (q\[1\] & 1),main(2,e)

## , q\[0\] -= 1 + (q\[1\]

## & 1) ) ), r; }

char

\_3141592654\[3141

\],\_\_3141\[3141\];\_314159\[31415\],\_3141\[31415\];main(){register
char\*

\_3\_141,\*\_3\_1415, \*\_3\_\_1415; register int
\_314,\_31415,\_\_31415,\*\_31,

\_3\_14159,\_\_3\_1415;\*\_3141592654=\_\_31415=2,\_3141592654\[0\]\[\_3141592654

\-1\]=1\[\_\_3141\]=5;\_\_3\_1415=1;do{\_3\_14159=\_314=0,\_\_31415++;for(
\_31415

\=0;\_31415\<(3,14-4)\*\_\_31415;\_31415++)\_31415\[\_3141\]=\_314159\[\_31415\]=
-

1;\_3141\[\*\_314159=\_3\_14159\]=\_314;\_3\_141=\_3141592654+\_\_3\_1415;\_3\_1415=

\_\_3\_1415 +\_\_3141;for (\_31415 = 3141-

\_\_3\_1415 ; \_31415;\_31415—

,\_3\_141 ++, \_3\_1415++){\_314

\+=\_314\<\<2 ; \_314\<\<=1;\_314+=

\*\_3\_1415;\_31 =\_314159+\_314;

if(\!(\*\_31+1) )\* \_31 =\_314 /

\_\_31415,\_314 \[\_3141\]=\_314 %

\_\_31415 ;\* ( \_3\_\_1415=\_3\_141

)+= \*\_3\_1415 = \*\_31;while(\*

\_3\_\_1415 \>= 31415/3141 ) \*

\_3\_\_1415+= - 10,(\*--\_3\_\_1415

)++;\_314=\_314 \[\_3141\]; if ( \!

\_3\_14159 && \* \_3\_1415)\_3\_14159

\=1,\_\_3\_1415 = 3141-\_31415;}if(

\_314+(\_\_31415 \>\>1)\>=\_\_31415 )

while ( ++ \* \_3\_141==3141/314

)\*\_3\_141--=0 ;}while(\_3\_14159

) ; { char \* \_\_3\_14= "3.1415";

write((3,1), (--\*\_\_3\_14,\_\_3\_14

),(\_3\_14159 ++,++\_3\_14159))+

3.1415926; } for ( \_31415 = 1;

\_31415\<3141- 1;\_31415++)write(

31415% 314-( 3,14),\_3141592654\[

\_31415 \] + "0123456789","314“

\[ 3\]+1)-\_314; puts((\*\_3141592654=0

,\_3141592654)) ;\_314= \*"3.141592";}

© 1989 Roemer B. Lievaart

© 1993 E. Jay Berkenbilt
