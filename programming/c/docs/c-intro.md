---
title:  Introduction to C
author: CSC Summerschool 
date:   2019-07
lang:   en
---


# What is C?

- C is a *general-purpose* programming language initially developed by
Dennis Ritchie between 1969 and 1973 at AT\&T Bell Labs

- It is an imperative procedural language intended for system software
  * Strong ties with UNIX operating system
- It has influenced many other programming languages
  * C++, C\#, ObjC, Java, JavaScript, Go, csh, ...

# Why C?

 - It’s popular and widely used

  * Available on almost all platforms
  * Lots of libraries for different tasks

- Provides a relatively low-level (or mid-level) access to the operating
 system and hardware

  * System-level programming, embedded systems
  * Can lead to better performance

# Standards

- First standard by ANSI in 1989, known as “ANSI C” or C89

  * Still the best choice when portability is important\!
  * ISO adopted the same standard in 1990 (C90)

- Next revision in 1999, C99

  * New datatypes, complex numbers, variable length arrays,...

- Current standard is C11

  * Improved Unicode support, atomic operations, multi-threading, bounds-checked functions, ...

**On this course we will use mainly ANSI C/C90 or C99**

# Getting started{.section}

# Look and feel
<small>
```c
/* Computing the factorial of an specified (by the user) number */
#include <stdio.h>

int fact(int n);

int main(void){
	int current;
	printf("Enter some POSITIVE integer (non-positive to finish): ");
	scanf("%d", &current);
	while (current > 0) {

		printf("Factorial of %d is %d\n", current, fact(current));

		printf("Enter a POSITIVE integer (non-positive to finish): ");

		scanf("%d", &current);
	}
}
/* This function returns the factorial of the specified integer (n)*/
int fact(int n) {
...
```
</small>

# Basic syntax

<div class="column">
  - Code is case sensitive
  - Statements terminate with ;
  - {} enclose blocks
  - There are two ways to comment :

```c
/* This is a very long and complicated comment,
which contains a lot of useful information */

// This is a short comment
```
</div>

<div class="column">
```c
/* example function */
float foo(int bar) {
	int i, c=0;
	float x;
	x = 0.1;
	for (i=0; i\<bar; i++) {
		x += i\*3.14 + c;
		c = i + 2;
	}
	return x;
}
```
</div>

# Basic syntax

Free format

  - whitespace, newlines, layout etc. do not matter …
**To the computer!!**

<div class="column">
```c
/* example function */
float foo(int 
bar) {int i,c=0;float x;x = 0.1;for
(i     =0;i<bar;
i++) {
x += i*3.14       + c;
c = i + 2;}return x;}
```
</div>
<div class="column">
```c
/* same example function? */
float foo(int bar) {
	int i, c=0;
	float x;
	x = 0.1;
	for (i=0; i<bar; i++) {
		x += i*3.14 + c;
		c = i + 2;
	}
	return x;
}
```
</div>
# Simple Input / Output (I/O)

  - stdio-library is almost always needed. To include it use:  
	`#include <stdio.h>`
  - For printing a text on the screen:
	`printf(<template> {, <variables>})`

	* `<template>` arbitrary string with optional placeholders for data from variables
	* `<variables>`	(optional) a list of variables

# Basic I/O

- Special characters that can be used in the template string:  
**\\n** newline	      
**\\t** horizontal tab  
**\\”** double quote	 
**\\\\** literal backlash  
- Placeholders are marked with **%** followed by formatting and type
information

  * For now, we will just use the following formattings:   
  **%d** integer value  
  **%f** float value  
  **%s** string

# Basic I/O example
```c
#include <stdio.h>
int main(int argc, char *argv[]) {
	printf("The answer is %d.\n", 42);
	printf("Pi equals to %.2f", 3.14159265);
	printf(" ...at least to the %dnd decimal.\n", 2);
	return 0;

}

//output:
// The answer is 42.
// Pi equals to 3.14 ...at least to the 2nd decimal.
```
# **The transition from Code to program**

<div class="column">
- Compiling:

  * Transforming the C source code to machine language

- Linker:

  * Combines object files generated by the compiler into a single executable program

- The result is an executable binary file
</div>
<div class="column">
```c
/*file.c*/
#include <stdio.h>
void main() {
int i,j=0;
float f=1.0;
for (i=0; i<8; i++) {
	j += i;
	f *= j+i;
}
```
<small>
**file.c**->**prepreocessor**->**compiler**->**linker**->**program**  
</small>


# Let's try it out\!
<small>
  
  - Write the classic first program in C:

  ```c
  #include<stdio.h>
  void main(){
  	printf("Hello World!\n");
  }

  ```
  
  - Compile the code:
  
  ```bash
  $ gcc -o hello hello.c
  ```
  - Test your program:
  
  ```bash
  $ ./hello
  Hello World!
  ```

</small>

# Datatypes, variables, assignment and operators{.section}

# Basic data types

  - Basic datatypes in C are: 
  	* **char** character 
  	* **int** integer number
  	* **long** long integer number 
  	* **float** floating point number
  	* **double** double precision float
  - C has also *pointer* types
  - There is also a special type **void**

# Variables
<div class="column">
  - Data types of the variables are static
  - Declare variables before using them
  - Valid variable names in C:  
  	`[a-z][A-Z][0-9]_`
  - Scope of a variable is always local unless otherwise declared
</div>

<div class="column">
```c
// variable declaration
int i;
float f, g;
double total=1.9;
// valid names
int i3, myINT, I_o;
float o3Gf_ry9;
// invalid names
int 33, 9a, i-o;
float o3.Gf;
// data type matters
char c;
float f;

f = 1.234;
c = f; // ERROR!, wrong data type
```
</div>
# Variable assignment
<div class="column">
- Assign a value to a variable: **variable = value;**  

- Both should have the same data type

  * implicit conversion between compatible types
  * explicit conversion (typecast) syntax: **(type) var**
</div>
<div class="column">
```c
// examples of assignment
count = 10;
i = j = 0;
k = i*j + 1;

// assign at declaration
int i = 4;

// typecast from int to float
int i;
float f;
i = 5 * 21;
f = (float) i;

// watch out for operator order
(float) i/5 != (float) (i/5)
```
</div>


# Arithmetics

- Operators: 
	* `+` addition 
	* `-` subtraction 
	* `*`  multiplication 
	* `/` division
	* `%` modulus

- Operator precedence

  1. `% * /`
  2. `+ -`

Parentheses `()` group operations and change evaluation order


# **Compound assignment**

<div class="column">
  - C has a short-hand notation for combined arithmetic operation and assignment  
    `a += b <--> a = a+b`   
    `a -= b <--> a = a-b`   
    `a *= b <--> a = a*b`  
    `a /= b <--> a = a/b`  
  - For special cases `a+=1` and `a-=1` there are special operators  
  `++` and `--`

</div>
<div class="column">
```c
// example of compound assignment
int count = 10;

count += 5; // now count is 15

count /= 3; // and now count is 5

// Adding one to count
count++;

// This is also valid\!
++count;
```
</div>

# Arithmetics and assignment examples
<div class=column>
```c
// addition, substraction
 i = 5 + 2;
 i = 5 – 2;
 i += 1; // i = i + 1
 f -= 3.4;
 i++; // i = i + 1
 i--;

 // multiplication, division
 i = 5 * 2;
 i = 5 / 2; // integer division
 f *= 3.0 / 4.2;

 // modulus
 m = 25 % 3;
```
</div>
<div class=column>
```c
// grouping with ()s
b = a * (1.3 + (25%3));

// watch out!
f = 1 + q / (1 - q);
f = (1 + q) / (1 - q);

// also functions use ()
f = r * sin(theta);
f = (r + p)*sin(theta);

```
</div>

# Pointers

  - A variable is actually a reference to a memory location
  - The contents of the memory block determine the value of a variable
  - Memory addresses can be stored (and manipulated) in pointers
  - Pointers are one of the key features (and one of the most difficult) of the C language!

# Pointers
  - Pointers have a type (**int, char** etc.)
  - Stores a memory address containing data of corresponding type
  ![](pointer1-01.svg){.center width=100%}  

# Pointers

  - The address of a variable is obtained with `&`
  - The value pointed at by a pointer (the contents of the address) can 
  be accessed by de-referencing the pointer with `*`
```c
int *p, a;
a = 5;

// get address of a
p = &a;

// assign to a the value pointed at by *p plus 2
a = (*p) + 2; // a=7
```

# Summary

  - Short history and different standards
  - Basic syntax
  - Variables and their type, assignment of values
  - Arithmetic operations

# Control structures and loops {.section}

# Control structures // if – else 
<div class=column>
  - if (_conditional_) {_TRUE_} else {_FALSE_}
  - negation: **!**
  - non-zero value == TRUE
```c
if (i < 100) {
    data[i] = x[i] + c
} else {
    data[i] = x[i] - c
}
```
  
</div>
<div class=column> 
Test operators:
```
== equal to

!= not equal to

&& AND

|| OR

< less than

> greater than

<= less or equal

>= greater or equal
```
</div>

# Control structures // if – else
<div class=column>
 ```c
 // simple if-else
 if (x > 1.2) {
	 y = 4*x*r; // TRUE
 } else {
 	y = 0.0; // FALSE
 }

 // else is optional

 if (x || y) {
 	z += x + y;
 }
```
</div>

<div class=column>
```c
// complex if-elseif-else

if ((x > 1.2) && (i != 0) ){
	y = x / i; // 1st TRUE
} else if (x < 1.0 ) {
	y = -x; // 1st FALSE
// 2nd TRUE
} else {
	y = 0.0; // 1st, 2nd FALSE
}
```
</div>

# Control structures // switch
```
switch (...) {		// conditional expression 
	case (...):  	// test value
		...	// Do something
		break;  // end of branch
	default:  	// default branch executed if nothing else matches
		...	// Do something
	}
```
- condition:

  * single variable OR complex expression

- branch(=case) with matching value chosen

- break stops branch

# Control structures // switch
```c
 // simple switch based on the
 // value of integer i
 switch (i) {
 	case 1:
 		printf("one\\n");
 		break;
 	case 2:
		printf("two\\n");
		break;
	default:
		printf("many\\n");
		break; //  good style to break even the last branch
	}

```
# Control structures // switch

<div class=column>
<small>
```c
// A
switch (i) {
	case 1:
		printf("one\\n");
	case 2:
		printf("two\\n");
	default:
		printf("many\\n");
}
```
```c
// C
switch (i) {
	case 1:
		printf("one\\n");
		break;
	case 2:
		printf("two\\n");
		break;
	default:
		printf("many\\n");
}
```
</small>

</div>

<div class=column>
<small>
```c
// B
switch (i) {
	default:
		printf("many\\n");
	case 1:
		printf("one\\n");
		break;
	case 2:
		printf("two\\n");
		break;
}
```
</small>
In each case, what would be printed on the screen if i is 1, 2, or 3?

</div>


# Loops // while
- **while (_condition_) {_code block_}**
```c
i = 0 // loop i = 0..99 with an increment of one
while (i<100) {
	data\[i\] = x\[i\] + c
	i++;
}
```
- Code block executes repeatedly as long as condition is TRUE

- Condition executed *before* iteration

- **do {...} while (...)**

  - Block executed at least once



# Loops // for
- **for (\<init\>; \<condition\>; \<after\>) {...}**

```c
// loop i = 0..99 with an increment of one
for (i=0; i<100; i++) {
	data[i] = x[i] + c
}
```
* **\<init\>** execute once before entering the loop
* **\<condition\>** stop loop when condition is FALSE
* **\<after\>**	execute after each iteration


# Loops // for
```c
 // loop using a for-statement
 // i is incremented after each iteration
 for (i=0; i\<bar; i++) {
 	x += i\*3.14 + c;
 	c = i + 2;
 }
```
 
```c
 // the same loop but with a while-statement
 i=0;
 while (i < bar) {
 	x += i\*3.14 + c;
 	c = i + 2;
 	i++;
 }
```


# Jump statements

<div class=column>
- **break**

  * end a loop (for, while, do) or a switch statement

- **continue**

  * continue with the next iteration of a loop
</div>
<div class=column>
```c
// jump out of a loop
for (i=0; i\<10; i++) {
	printf("in loop");
	if (i == x)
		break;
}
```
```c
// jump to the next iteration
for (i=0; i\<10; i++) {
	if (i \< x)
		continue;
	printf("in loop");
}
```
</div>
# Summary

  - Conditional branching: **if-else**, **switch**
  - Looping as long as condition is true: **while**, **do – while**
  - Fixed number of loop passes: **for**
  - Jump statements: **continue**, **break**

# Data structures and functions {.section}

# Arrays

  - Static arrays declared as **\<type\> name\[N\]** where **N** is the size of the array   
    * **int i\[10\]** array of 10 integers   
    * **float f\[3\]** array of 3 floats   
    * **char c\[60\]** string of 60 letters  
  - elements indexed starting from zero   
  	* **i\[3\]** 4th element of array i  
  - multi-dimensional arrays possible   
  	* **int m\[10\]\[20\]** a 10x20 matrix

# Arrays
<div class=column>
```c
 // integer vector
 int triplet[3];
 triplet[0] = 1;
 triplet[1] = 2 * triplet[0];
 triplet[2] =
 triplet[0] + triplet[1];

 // string
char word[] = "hello!";
printf(word); // hello!
```
</div>
<div class=column>
```c
// 2-dim matrix
int i,j;
float matrix[5][5];

for (i=0; i<5; i++){
	for (j=0; j<5; j++){
		matrix[i][j] = i*j;
		}
	 }

// print the 2nd row
for (i=0; i<5; i++){
	printf("%f ", matrix[1][i]);
	}
```
</div>

# Pointer arithmetic and arrays

- Pointers can be added to or subtracted from

  * This shifts the pointer to a new memory address before or after the
    current one
  * Each step is **sizeof(pointer\_datatype)** bytes, i.e. the memory size of the pointer's data type
(Watch out for out-of-bounds memory errors!)

```c
float vector[10], *ptr;

ptr = &vector[0]; // *ptr -> vector[0]
ptr = vector; // name of array works as pointer to the beginning
ptr++; // *ptr -> vector[1]
ptr += 3; // *ptr -> vector[4]
ptr--; // *ptr -> vector[3]
```
# Structures
<div class=column>
  - Multiple variables of arbitrary type can be grouped together in a
    **struct**
  - Member **y** of struct **x** accessed with **x.y** (or **x-\>y** if
    x is a pointer)
</div>
<div class=column>
<small>
```c
struct s {
	int i;
	float f;
} one;

typedef struct {
	int count;
	float price;
} apple;

apple a;
a.count = 7;
a.price = 1.24;
cost = a.count * a.price;

// with pointers
apple *ptr;
ptr = &a;
c = ptr->count;
ptr->price = 0.89;
```
</small>
</div>
# Functions

- Functions are the only subroutine type in C

  * But functions do not have to return anything

Function definitions are of form
```
type func-name(param-list)
{

/* body of function */

}
```

- Here **type** is the return type of the function

  * **void** means that function does not return anything


# main function

- Every C program has the main function with definition
```
int main(int argc, char *argv[])
{

/* body of function */

}
```
- Command line arguments are passed to the program using **argc** and **argv**

- main should always return integer

  * zero means success, non-zero values are errors


# Function example

  - This function returns the sum of two integer arguments:
```c
#include <stdio.h>

int add(int a, int b) {
	return a + b;
}

int main(void) {
	int val;
	val = add(3, 6);
	printf(“Sum is %i\n”, val);
	return 0;
}
```

# **Variable scoping**

<div class=column>
- Variable scoping in C is local unless defined otherwise

  * Variables declared in the function definition are only visible
   inside the function body
  * Variables of calling scope are not visible inside function body
</div>
<div class=colum>
```c
void funcB(float a) {
	int counter;//Not accessible from funcA
	...
}

int funcA(void) {
	float value1, 
	value2;//Not accessible from funcB 
	funcB(value1);
	...
}
```
</div>

# Arguments
<div class=column>
- All arguments are passed as *values*

  * Copy of the value is passed to the function
  * Functions can not change the value of a variable in the *calling scope*

- Pointers can be used to pass a reference to a variable as an argument!
</div>
<div class=column>
```c
void funcB(int a) {

	a += 10;

}

int funcA(void) {
	int var = 0;
	funcB(var);
	// var is still 0\!
	...
}
```
</div>

# Functions with pointers

  - Pointers allow “returning” of multiple values
```c
// passing by reference
void add_pi(float *a, int *b) {
	float pi=3.14;
	*a += pi;
	(*b)++;
}

float a=1.0;
int b=1;
add_pi(&a, &b); // a=4.14 b=2
```


# Dynamic arrays{.section}

# Dynamic memory management

  - In most cases the exact size of all data structures is not known at 
  compile time because they depend on the input data
  - Dynamic memory management is accomplished by using pointers and 
  manually managing memory (de)allocation
  - Relevant functions are **malloc()**, **realloc()**, **free()**

# malloc

- malloc function is defined in header file stdlib.h: 
	* **void\* malloc(size\_t size);**

- **malloc** returns a pointer of type **void** to a memory location with
allocated space of size **size** bytes

  * If allocation fails, **malloc** returns **NULL\!**

- The memory area returned by the malloc is uninitialized!

# Dynamic arrays

- **malloc** can be used to allocate space for arrays

  * **malloc** returns a pointer to the beginning of the array
  * Elements can be accessed with normal array syntax

- The size of memory allocation can be determined using **sizeof**
operator which returns the size of the argument in bytes

- Example for a dynamic array of five integers: 
	* **int \*ptr = (int \*) malloc(5 \* sizeof(int));**

# free

- **free** deallocates previous allocated object 
	* **void free(void\*ptr);**

- After freeing you should not try to access any part of the allocation

- Calling free with a pointer that does not point to a allocated memory
can crash the code

  * Calling free twice is a common mistake\!

# Dynamic arrays
```c
 int n_elems = 32;
 float *prices;

 // allocate memory for the required amount of floats
 prices = malloc(n_elems*sizeof(float));
 for (i=0; i<n_elems; i++) {
	prices[i] = i*1.23;
 }

 // add space for one more float
 prices = realloc(prices, sizeof(float)*(n_elems+1));
 prices[n_elems] = 0.91;

 // de-allocate the memory block
 free(prices);
```

# Pointers to pointers

- It is possible to have pointer references to pointers

  * This is very useful when functions have to manipulate values of arguments of pointer type
  * Multidimensional arrays are also naturally mapped into pointers of pointers

# Pointer to a pointer example
```c
#include<stdio.h>

int main(void) {
	int a = 5;
	int *int_ptr;
	int **int_ptr_ptr;
	int_ptr_ptr = &int_ptr;
	int_ptr = &a;
	printf(“a=%i\n”, **int_ptr_ptr);
	return 0;
}
// Result: a=5
```

# Dynamic multi-dimensional arrays

- Doable, but becomes complicated

- No real multi-dimensional arrays in C, so really just arrays of arrays

  * Two dimensional array maps to a variable that is a pointer to a pointer

- Memory management by hand

  * There are at least two different ways to do the allocation
  * Easy to make mistakes, _beware here lieth dragons!_

- Often best to just use 1D array and map N dimensional indices

# Allocating row-by-row
<div class=column>
```c
 int i;
 int rows = 4, cols = 8;
 float **matrix;

 /* allocate memory */
 matrix = malloc(rows * sizeof(float *));
 for (i = 0; i < rows; i++){
 	matrix[i] = malloc(cols * sizeof(float));
 }
 
 // start using the 2D array
 matrix[0][2] = 3.14;
```
</div>
<div class=column>
![](allocation1-01.svg){.center width=80%}  
**Do not do this!**
</div>

# Dynamic multi-dimensional arrays

- Dynamic 2D array in *contiguous* memory:
  * First, allocate memory for pointers to the first element of each row
  * Second, allocate memory for all elements
  * Third, point each row at the first element of that row

# Dynamic multi-dimensional arrays
<small>
```c
 /* allocate memory */
 matrix = malloc(rows * sizeof(float *));
 matrix[0] = malloc(rows * cols * sizeof(float));
 /* point the beginning of each row at the correct address */
 for (i = 0; i < rows; i++){
 	matrix[i] = matrix[0] + i * cols;
 }
 // start using the 2D array
 matrix[0][2] = 3.14;
```
![](allocation2-01.svg){.center width=100%}
</small>

# **Memory layout**

- Allocating space for the whole array using a single malloc call is the
recommended way

  * Number of expensive malloc calls is minimized
  * Array is represented as one contiguous block in memory
  * It can be copied without looping over rows
  * Most IO and numerical libraries assume contiguous storage

# Dynamic multi-dimensional arrays

  - After using a dynamic multi-dimensional array, remember to free each array inside the main array

```c
 /* When using contiguous memory */

 free(matrix[0]);

 free(matrix);
```

# Using indexing to represent 2D array

- Allocate memory for all elements as normal 1D array
- Compute indices so that the 1D memory area map to the 2D array we want to represent
- Benefits
  * The compiler understands better the code, and hence performance may be better
  * Allocation and deallocation easier
  * Straightforward to generalize to higher dimensions
- Drawbacks
  * Code may look less elegant

# Using indexing to represent 2D array
```c
 /* matrix now normal pointer */
 float *matrix;
 /* allocate memory */
 matrix = malloc(rows * cols * sizeof(float));
 /* start using the array, element [i][j] in 2D array now maps to [i * cols + j]*/
 matrix[0 * cols + 2] = 3.14;
 /* free memory */
 free(matrix);
```
![](allocation3-01.svg){.center width=100%}

# Preprocessing and libraries {.section}

# Preprocessing directives

- C preprocessor is a part of the compiler that does initial text
substitution, manipulation, inclusion and other activities before the
actual translation is done

  * We have already used **\#include**, which includes a file

- C relies heavily on preprocessor to accomplish

  * Portability of code
  * Source code control
  * Debugging

# Directives

- Preprocessor directives start with **\#**, which has to be first token
on a line

- Directives are limited to one line

  * Line can be continued using **\\**

- Directives are not statements, do not end the line with **;**
```c
// These are ok
#define one
	#define two

// Not the first token - WRONG!
int i; #define one
```


# \#define

  - **\#define** can be used to define “objects” or macros
  - It has the form of **\#define** ***identifier*** ***replacement***
  - After the definition all instances of ***identifier*** are replaced with ***replacement***
```c
// Example
#define ONE 1

printf(“Value is %i\n”, ONE);

// Result: Value is 1
```
# Directives

- **\#ifdef, \#ifndef**

  * checks whether a macro is defined (/ not defined)
  * if check is true, then includes the enclosed code

```c
#include <stdio.h>
#include "myfile.h"

#define DEBUG 1
#define PI 3.14159
#define MAX(a,b) (a)>(b)?(a):(b)

#ifdef DEBUG
/* debug mode is enabled */
#endif
```

# Definitions on compiler command line

  - It is also possible to set preprocessor definitions on the compiler command line
  - Most compilers accept option **-D** for this purpose:  
   **gcc -DONE=1 -DUSE\_FEATURE**  
   is equivalent with   
   **\#define ONE 1   
   \#define USE\_FEATURE**

# The transition from Code to program
<div class=column>
- Compiling:

  * Transforming the C source code to machine language

- Linker:

  * Combines object files generated by the compiler into a single
    executable program

- The result is an executable binary file
</div>
<div class=column>
![](codeToP-01.svg){.center width=80%}
</div>

# **Working with several files and libraries**

- Advantages:

  * Different programmers can work on different files
  * Function definitions can be re-used in other programs
  * Changing a file, only that file needs to be re-compiled to rebuild the program

- UNIX ‘make’ can be very useful tool for this!

  * Most IDEs also provide a tools for building this kind of compilation

# Compilation: working with several files
<div class=column>
  - We use header files to define functions that we can use later
  - Making .h files for your functions allows you to ‘include’ them in your code
  - Function prototypes introduce the return value, name and argument of the function
  to the compiler
</div>
<div class=column>
```c
// we implement the function ‘add’
int add(int first, int second){
	return first + second;
}
```

```c
// we define the function ‘add’
#ifndef ADD_H
#define ADD_H

// Function prototype
int add(int first, int second);
#endif
```
</div>


# Compilation: working with several files

  - Another .c file can then use the function **add()** by including theheader file:
```c
// we can use #include "" or #include <>
#include "add.h"

int example(int x){
	return add(x, add(x,x));
}
```

# Compilation: working with several files

- So, this is how headers work:

  * main() would be in one file, the others will contain functions
  * Headers usually only contain definitions of data types, function prototypes and C preprocessor commands
  * We include the header into the C files
  * We compile the different files and the compiler calls the header file

# The transition from Code to program

- In complex projects:
	* Compile each source code file (.c) into an object file (.o)
```bash
$ gcc -c main.c
$ gcc -c add.c
```
	* Link object files into a binary and execute the binary
```bash
$ gcc -o foo main.o add.o
$ ./foo
Modify “add.c”
$ gcc –c add.c
$ gcc -o foo main.o add.o
$ ./foo
```

# Libraries

- Libraries contain functions, data types and constants that can be used
by multiple programs

- Two components:

  * header: function etc. definitions
  * object code in a library file (shared .so or static .a)

- When creating the executable binary file, an additional flag
(–l*library\_name*) is given to the linker to include the library

# Libraries
<div class=column>
  - Math operations  
   **\#include \<math.h**\>  
   \+ link with -lm flag\!
  - It includes the most common mathematical functions, e.g. sin(), cos(), log() etc.
  - Also includes constants such as M\_PI for π
  - For power operation function pow() is used (^ is bit-wise XOR in C!)
</div>
<div class=column>
```c
#include <math.h>
int main () {
	float r, theta;
	double area, y;
// radius and an angle
	r = 1.2;
	theta = 0.456;
// calculate something
	area = M_PI * pow(r,2);
	y = sin(theta)+ cos(theta/2.0);
	y += exp(-3.1 * area);
// echo results
	printf("area is %f\n", area);
	printf("y=%.18e\n", y);
}
```
</div>





# Linking with libraries


  - Add libraries in linking phase
```bash
$ gcc -c main.c
$ gcc -o foo main.o -lm
$./foo
```
# Compiler optimization

 - Compiler flags provides possibilities of also for code optimization. Few instances of the optimization flags are  
 **-O, -O0, -O1, -O2, -O3, -Os.**
```bash
$ gcc -O3 -o toroid -lm toroid.c
$ ./toroid
```
  - For further information check the manual of gcc:
```bash
$ man gcc
```


# File I/O{.section}

# **File I/O**

  - **FILE\* fopen(\<filename\>, \<mode\>)**
  	* **\<filename\>** name of a file
	* **\<mode\>** read (r), write (w), append (a), read+write (r+w), binary mode (rb) ...
	* **FILE** pointer to file
  - **fclose(FILE\*)** closes file
  - **fflush(FILE\*)** flush I/O buffer to disk


# File I/O

- **stdout, stderr**

  * special output streams for STDOUT and STDERR (stdio.h)

- **fprintf(\<file\>, \<template\> {,\<variables\>})**

 	* **\<file\>** pointer to an open file

 	* **\<template\>** arbitrary string with optional placeholders for data from variables

 	* **\<variables\>** (optional) a list of variables

# File I/O
```c
#include <stdio.h>

fprintf(stdout, "The answer is %d.\n", 42);
//output (STDOUT):
// The answer is 42.

fprintf(stderr,"Pi equals to %.2f (at least to the %dnd decimal).\n",3.14159265, 2);
//output (STDERR):
// Pi equals to 3.14 (at least to the 2nd decimal).
```
# File I/O
```c
 #include <stdio.h>

 FILE *fp;
 int pid=2146;

 fp = fopen("mylog", "w");
 fprintf(fp, "logging my progress for process %d...", pid);
 fprintf(fp, "ok\n");
 fclose(fp);

 //output (in file 'mylog'):
 // logging my progress for process 2146...ok
```


# File I/O

- **fgets(char \*buffer, int size, FILE \*stream)**

  * Reads a single line from file pointer stream
  * Assigns string to buffer
  * The size parameter defines the max. size of characters to read.

# File I/O

- **fscanf(FILE \*stream, char \*format, ...)**

  * scan input according to format e.g. "name: %s age: %d"
  * store values of placeholders (%s etc.) to pointers

```c
// read max 64 characters from FILE *fp
fgets(buffer, 64, fp);

// read a matching string from FILE *fp, pick a string and
// an integer and assign them to variables name and age
fscanf(fp, "name: %s age: %d", &name, &age);
```

# Summary

  - Basic syntax
  - Overall structure: _\#include, functions, main()_
  - Data types: _int, float, ..., struct_
  - Control structures: _for, while, if/else, switch/case_
  - Memory management: _pointers, malloc(), ..._
  - I/O: _files, stdin, stdout_
  - Compiling & linking

# Web resources

  - C Programming  
    [http://en.wikibooks.org/wiki/C\_Programming](http://en.wikibooks.org/wiki/C\_Programming)
  - The C Library Reference Guide  
    [http://www.acm.uiuc.edu/webmonkeys/book/c\_guide/](http://www.acm.uiuc.edu/webmonkeys/book/c\_guide/)
  - C syntax   
    [http://en.wikipedia.org/wiki/C\_syntax](http://en.wikipedia.org/wiki/C\_syntax)
  - Ten Reasons to Teach and Learn Computer Programming in C  
    [http://iel.ucdavis.edu/publication/WhyC.html](http://iel.ucdavis.edu/publication/WhyC.html)
  - International Obfuscated C Code Contest  
    [http://en.wikipedia.org/wiki/International\_Obfuscated\_C\_Code\_Contest](http://en.wikipedia.org/wiki/International\_Obfuscated\_C\_Code\_Contest)

# Say what?
![© 1993  E. Jay Berkenbilt](obf.svg){.center width=20%}


